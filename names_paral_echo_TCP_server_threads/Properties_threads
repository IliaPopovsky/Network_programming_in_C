Создание потока требует в 10-100 раз меньше времени, чем создание процесса.
Все потоки одного процесса совместно используют его глобальные переменные, поэтому им легко обмениваться информацией, но это приводит к необходимости синхронизации (последоватизации).
Однако общими становятся не только глобальные переменные. Все потоки одного процесса разделяют:
- инструкции процесса;
- большую часть данных;
- открытые файлы (например, дескрипторы);
- обработчики сигналов и вообще настройки для работы с сигналами (действие сигнала);
- текущий рабочий каталог;
- идентификаторы пользователя и группы пользователей;
У каждого потока имеются собственные:
- идентификатор потока;
- набор регистров, включая счетчик команд и указатель стека;
- стек (для локальных переменных и адресов возврата);
- переменная errno;
- маска сигналов;
- приоритет;

                                                                                                                                           У.Р. Стивенс "UNIX разработка сетевых приложений. 3-е издание"
=========================================================================================================================================================================================================
11.1. Введение
Все потоки внутри процесса имеют доступ к одним и тем же компонентам процесса, таким как файловые дескрипторы или глобальные переменные.

Всякий раз при попытке организовать одновременный доступ нескольких пользователей к одному и тому же ресурсу приходится сталкиваться с проблемой согласования доступа.


11.2. Понятие потоков
Типичный процесс в UNIX можно представить как имеющий единственный поток управления - каждый процесс в один момент времени решает только одну задачу. При использовании нескольких потоков управления можно спроектировать приложение, которое будет решать одновременно несколько задач в рамках единственного процесса, где каждый поток решает отдельную задачу. Такой подход имеет следующие преимущества:
- Можно значительно упростить код, обрабатывающий асинхронные (параллельные, одновременные) события, привязав каждый тип события к отдельному потоку. В результате каждый поток сможет обслуживать свое событие, используя для этого синхронную (последовательную) модель программирования, которая намного проще асинхронной (параллельной).
- Чтобы организовать совместный доступ нескольких процессов к одним и тем же ресурсам, таким как общая память или файловые дескрипторы, необходимо использовать достаточно сложные механизмы синхронизации (последоватизации), предоставляемые операционной системой. Потоки же, в отличие от процессов, автоматически получают доступ к одному и тому же адресному пространству своего процесса владельца и файловым дескрипторам.
- Решение некоторых задач можно разбить на более мелкие подзадачи, что может дать прирост производительности программы. Однопоточный процесс, выполняющий решение нескольких задач, неявно вынужден решать их последовательно, поскольку имеет только один поток управления. При наличии нескольких потоков управления независимые друг от друга задачи могут решаться одновременно отдельными потоками. Две задачи могут решаться одновременно только при условии, что они не зависят друг от друга. 
- Аналогично, интерактивные программы могут сократить время отклика на действия пользователя, используя многопоточную модель, чтобы отделить обработку ввода/вывода пользователя от других частей программы.

У многих многопоточное программирование ассоциируется с многопроцессорными системами. Однако преимущества многопоточной модели проявляют себя, даже если программа работает в однопроцессорной системе. Независимо от количества процессоров, программу можно упростить благодаря многопоточной модели, поскольку количество процессоров не влияет на структуру программы. Кроме того, в то время как однопоточный процесс вынужден периодически простаивать при последовательном решении нескольких задач, многопоточный может повысить производительность и в однопроцессорной системе, т.к. часть потоков могут продолжать работу, когда другие простаивают, ожидая наступления некоторых событий.


11.4. Создание потока
При создании нового потока нельзя заранее предположить, кто первым получит управление - вновь созданный поток или поток, вызвавший функцию pthread_create. Новый поток имеет доступ к адресному пространству процесса и наследует от вызывающего потока среду окружения арифметического сопроцессора и маску сигналов, однако набор сигналов, ожидающих обработки, для нового потока очищается.


11.6.2. Предотвращение тупиковых ситуаций
Поток может попасть в тупиковую ситуацию (deadlock), если попытается дважды захватить один и тот же мьютекс, но есть и менее очевидные способы. Например, тупиковая ситуация может возникнуть, когда в программе используется несколько мьютексов и один поток, удерживая первый мьютекс, пытается запереть второй, в то время как другой поток аналогично удерживает второй мьютекс и пытается запереть первый.
В результате ни один из потоков не сможет продолжить работу, поскольку каждый будет ждать освобождения ресурса, захваченного другим потоком. Возникнет тупиковая ситуация.

Тупиковых ситуаций можно избежать, жестко определив порядок захвата ресурсов. Приведем пример. Предположим, что есть два мьютекса, A и B, которые необходимо запереть одновременно. Если все потоки сначала будут запирать мьютекс A, а потом B, тупиковой ситуации с этими мьютексами никогда не возникнет. Аналогично, если все потоки сначала будут запирать мьютекс B, а потом A, тупиковой ситуации с этими мьютексами также никогда не возникнет. Опасность попадания в тупиковую ситуацию возникает, только когда разные потоки могут попытаться запереть мьютексы в разном порядке.

Иногда архитектура приложения не позволяет заранее предопределить порядок захвата мьютексов. Если программа использует достаточно много мьютексов и структур данных, а доступные функции, которые работают с ними, не укладываются в достаточно простую иерархию, придется попробовать иной подход. Например, при невозможности запереть мьютекс можно отпереть захваченные мьютексы и повторить попытку немного позже. В этом случае во избежание блокировки потока можно использовать функцию pthread_mutex_trylock(). Если мьютекс удалось запереть с помощью pthread_mutex_trylock(), можно продолжить работу. Если мьютекс запереть не удалось, можно отпереть уже захваченные мьютексы, освободить занятые ресурсы и повторить попытку немного позже.




                                                                                                                                     У.Р. Стивенс "UNIX. Профессиональное программирование. 3-е издание"
=========================================================================================================================================================================================================
