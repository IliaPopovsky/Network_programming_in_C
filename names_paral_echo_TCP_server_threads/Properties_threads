26.1. Введение
Создание потока требует в 10-100 раз меньше времени, чем создание процесса.
Все потоки одного процесса совместно используют его глобальные переменные, поэтому им легко обмениваться информацией, но это приводит к необходимости синхронизации (последоватизации).
Однако общими становятся не только глобальные переменные. Все потоки одного процесса разделяют:
- инструкции процесса;
- большую часть данных;
- открытые файлы (например, дескрипторы);
- обработчики сигналов и вообще настройки для работы с сигналами (действие сигнала);
- текущий рабочий каталог;
- идентификаторы пользователя и группы пользователей;
- таймеры являются ресурсами процесса, и все потоки совместно используют один и тот же набор таймеров;
У каждого потока имеются собственные:
- идентификатор потока;
- набор регистров, включая счетчик команд и указатель стека;
- стек (для локальных переменных и адресов возврата);
- переменная errno;
- маска сигналов;
- приоритет;


26.8. Условные переменные
   Взаимное исключение (мьютекс) позволяет предотвратить одновременный доступ к совместно используемой (разделяемой) переменной, но для того чтобы перевести поток в состояние ожидания (спящее состояние) до момента выполнения некоторого условия, необходим другой механизм. Эта возможность обеспечивается использованием условной переменной (называемой также переменной состояния) (conditional variable) вместе со взаимным исключением (мьютексом). Взаимное исключение используется для реализации блокирования, а условная переменная обеспечивает сигнальный механизм.
   В терминах Pthreads условная переменная - это переменная типа pthread_cond_t. Такие переменные используются в следующих двух функциях: 
#include <pthread.h>

int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);
int pthread_cond_signal(pthread_cond_t *cond); 
Обе возвращают 0 в случае успеха, код ошибки — в случае неудачи
   Слово signal в названии второй функции не имеет отношения к сигналам Unix SIGxxx. 


                                                                                                                                           У.Р. Стивенс "UNIX разработка сетевых приложений. 3-е издание"
=========================================================================================================================================================================================================
11.1. Введение
Все потоки внутри процесса имеют доступ к одним и тем же компонентам процесса, таким как файловые дескрипторы или глобальные переменные.

Всякий раз при попытке организовать одновременный доступ нескольких пользователей к одному и тому же ресурсу приходится сталкиваться с проблемой согласования доступа.


11.2. Понятие потоков
   Типичный процесс в UNIX можно представить как имеющий единственный поток управления - каждый процесс в один момент времени решает только одну задачу. При использовании нескольких потоков управления можно спроектировать приложение, которое будет решать одновременно несколько задач в рамках единственного процесса, где каждый поток решает отдельную задачу. Такой подход имеет следующие преимущества:
- Можно значительно упростить код, обрабатывающий асинхронные (параллельные, одновременные) события, привязав каждый тип события к отдельному потоку. В результате каждый поток сможет обслуживать свое событие, используя для этого синхронную (последовательную) модель программирования, которая намного проще асинхронной (параллельной).
- Чтобы организовать совместный доступ нескольких процессов к одним и тем же ресурсам, таким как общая память или файловые дескрипторы, необходимо использовать достаточно сложные механизмы синхронизации (последоватизации), предоставляемые операционной системой. Потоки же, в отличие от процессов, автоматически получают доступ к одному и тому же адресному пространству своего процесса владельца и файловым дескрипторам.
- Решение некоторых задач можно разбить на более мелкие подзадачи, что может дать прирост производительности программы. Однопоточный процесс, выполняющий решение нескольких задач, неявно вынужден решать их последовательно, поскольку имеет только один поток управления. При наличии нескольких потоков управления независимые друг от друга задачи могут решаться одновременно отдельными потоками. Две задачи могут решаться одновременно только при условии, что они не зависят друг от друга. 
- Аналогично, интерактивные программы могут сократить время отклика на действия пользователя, используя многопоточную модель, чтобы отделить обработку ввода/вывода пользователя от других частей программы.
   У многих многопоточное программирование ассоциируется с многопроцессорными системами. Однако преимущества многопоточной модели проявляют себя, даже если программа работает в однопроцессорной системе. Независимо от количества процессоров, программу можно упростить благодаря многопоточной модели, поскольку количество процессоров не влияет на структуру программы. Кроме того, в то время как однопоточный процесс вынужден периодически простаивать при последовательном решении нескольких задач, многопоточный может повысить производительность и в однопроцессорной системе, т.к. часть потоков могут продолжать работу, когда другие простаивают, ожидая наступления некоторых событий.


11.4. Создание потока
При создании нового потока нельзя заранее предположить, кто первым получит управление - вновь созданный поток или поток, вызвавший функцию pthread_create. Новый поток имеет доступ к адресному пространству процесса и наследует от вызывающего потока среду окружения арифметического сопроцессора и маску сигналов, однако набор сигналов, ожидающих обработки, для нового потока очищается.


11.5. Завершение потока
   Если один из потоков вызовет функцию exit, _exit, или _Exit, будет завершен весь процесс. Аналогично, если потоку будет послан сигнал, действие которого заключается в завершении процесса, этот сигнал завершит весь процесс.
   Завершить работу единственного потока, т.е. без завершения всего процесса, можно тремя способами.
1. Поток может просто вернуть управление из запускающей процедуры (из функции компаньона). Возвращаемое значение этой процедуры (функции компаньона) - код завершения потока.
2. Поток можно принудительно завершить из другого потока в том же процессе.
3. Поток может вызвать функцию pthread_exit.


11.6.2. Предотвращение тупиковых ситуаций
Поток может попасть в тупиковую ситуацию (deadlock), если попытается дважды захватить один и тот же мьютекс, но есть и менее очевидные способы. Например, тупиковая ситуация может возникнуть, когда в программе используется несколько мьютексов и один поток, удерживая первый мьютекс, пытается запереть второй, в то время как другой поток аналогично удерживает второй мьютекс и пытается запереть первый.
В результате ни один из потоков не сможет продолжить работу, поскольку каждый будет ждать освобождения ресурса, захваченного другим потоком. Возникнет тупиковая ситуация.

Тупиковых ситуаций можно избежать, жестко определив порядок захвата ресурсов. Приведем пример. Предположим, что есть два мьютекса, A и B, которые необходимо запереть одновременно. Если все потоки сначала будут запирать мьютекс A, а потом B, тупиковой ситуации с этими мьютексами никогда не возникнет. Аналогично, если все потоки сначала будут запирать мьютекс B, а потом A, тупиковой ситуации с этими мьютексами также никогда не возникнет. Опасность попадания в тупиковую ситуацию возникает, только когда разные потоки могут попытаться запереть мьютексы в разном порядке.

Иногда архитектура приложения не позволяет заранее предопределить порядок захвата мьютексов. Если программа использует достаточно много мьютексов и структур данных, а доступные функции, которые работают с ними, не укладываются в достаточно простую иерархию, придется попробовать иной подход. Например, при невозможности запереть мьютекс можно отпереть захваченные мьютексы и повторить попытку немного позже. В этом случае во избежание блокировки потока можно использовать функцию pthread_mutex_trylock(). Если мьютекс удалось запереть с помощью pthread_mutex_trylock(), можно продолжить работу. Если мьютекс запереть не удалось, можно отпереть уже захваченные мьютексы, освободить занятые ресурсы и повторить попытку немного позже.


11.6.4. Блокировки чтения-записи
   Блокировки чтения-записи похожи на мьютексы, за исключением того, что они допускают более высокую степень параллелизма. Мьютексы могут иметь всего два состояния, закрытое и открытое, и только один поток может владеть мьютексом в каждый момент времени. Блокировки чтения-записи могут иметь три состояния: режим блокировки для чтения, режим блокировки для записи и отсутствие блокировки. Режим блокировки для записи может установить только один поток, но установка режима блокировки для чтения доступна нескольким потокам одновременно.
   Если блокировка чтения-записи установлена в режиме для записи, все потоки, которые попытаются захватить ее, будут приостановлены, пока блокировка не будет снята. Если блокировка чтения-записи установлена в режиме для чтения, все потоки, которые попытаются захватить ее для чтения, получат доступ к ресурсу, но если какой-либо поток попытается установить режим блокировки для записи, он будет приостановлен, пока не будет снята последняя блокировка для чтения. Разные реализации блокировок чтения-записи могут различаться существенно, но обычно, если блокировка для чтения уже установлена и имеется поток, который пытается установить блокировку для записи, остальные потоки, которые пытаются получить блокировку для чтения, будут приостановлены. Это предотвращает возможность блокирования пишущих потоков непрекращающимися запросами на получение блокировки для чтения.


12.6. Локальные данные потоков
Локальные данные потока - это механизм хранения и поиска данных, связанных только с конкретным потоком выполнения. Локальные данные потока нужны, чтобы каждый поток мог обладать некоторым набором данных, принадлежащих ему одному, и не беспокоиться о синхронизации при работе с ними.


12.8. Потоки и сигналы
Таймеры являются ресурсами процесса, и все потоки совместно используют один и тот же набор таймеров. Следовательно, в многопоточном приложении невозможно использовать таймеры в одном потоке, не оказывая влияния на другие.


                                                                                                                                     У.Р. Стивенс "UNIX. Профессиональное программирование. 3-е издание"
=========================================================================================================================================================================================================
